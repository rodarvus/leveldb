<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Plugin "leveldb" - A leveling database for Aardwolf -->

<muclient>
<plugin
   name="leveldb"
   author="Rodarvus"
   id="b34c04e52c6c7bced4508230"
   language="Lua"
   purpose="A simple leveling database for Aardwolf"
   date_written="2026-02-17 08:09:56"
   requires="5.07"
   version="1.0"
   save_state="y"
   >

</plugin>


<!--  Aliases  -->

<aliases>
   <alias
      match="^ldb$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_status"
   ></alias>
   <alias
      match="^ldb help$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_help"
   ></alias>
   <alias
      match="^ldb on$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_on"
   ></alias>
   <alias
      match="^ldb off$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_off"
   ></alias>
   <alias
      match="^ldb level$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_level_current"
   ></alias>
   <alias
      match="^ldb level (\d+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_level"
   ></alias>
   <alias
      match="^ldb zone$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_zone_current"
   ></alias>
   <alias
      match="^ldb zone (.+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_zone"
   ></alias>
   <alias
      match="^ldb mob (.+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_mob"
   ></alias>
   <alias
      match="^ldb top mobs$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_mobs_default"
   ></alias>
   <alias
      match="^ldb top mobs (\d+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_mobs"
   ></alias>
   <alias
      match="^ldb top zones$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_zones_default"
   ></alias>
   <alias
      match="^ldb top zones (\d+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_zones"
   ></alias>
   <alias
      match="^ldb top xp$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_xp_default"
   ></alias>
   <alias
      match="^ldb top xp (\d+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_xp"
   ></alias>
   <alias
      match="^ldb deaths$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_deaths_default"
   ></alias>
   <alias
      match="^ldb deaths (\d+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_deaths"
   ></alias>
   <alias
      match="^ldb db$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_db_info"
   ></alias>
   <alias
      match="^ldb db list$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_db_list"
   ></alias>
   <alias
      match="^ldb db switch$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_db_switch"
   ></alias>
</aliases>


<!-- Triggers -->

<triggers>
   <!-- Player damage line: [optional hits] Your spell VERB mob. [damage] -->
   <!-- Optional leading * for crits, optional [N] hits prefix, must start with "Your" -->
   <!-- Mob damage to player uses possessive mob name, not "Your", so won't match -->
   <trigger
      match="^\*?(?:\[\d+\] )?Your .+[.!] \[(\d+)\]\*?$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_damage_line"
      sequence="100"
   ></trigger>

   <!-- Player death -->
   <trigger
      match="^You die\.$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_player_death"
      sequence="100"
   ></trigger>
</triggers>


<script>
<![CDATA[
require "gmcphelper"

-- =============================================================================
-- Constants
-- =============================================================================
local GMCP_HANDLER_ID = "3e7dedbe37e44942dd46d264"
local SCHEMA_VERSION = 1
local PREFIX = "[LevelDB] "

-- =============================================================================
-- Plugin state (persisted via save_state)
-- =============================================================================
local enabled = false

-- =============================================================================
-- Database state
-- =============================================================================
local db = nil              -- SQLite database handle
local db_filename = nil     -- Current database filename (e.g., "ldb_T0R0.db")
local db_path = nil         -- Full path to current database

-- =============================================================================
-- GMCP cached values (updated on each broadcast)
-- =============================================================================
local cached_tier = nil
local cached_remorts = nil
local cached_perlevel = 1000
local cached_level = nil
local cached_tnl = nil
local cached_gold = nil
local cached_zone = nil
local cached_room_num = nil
local cached_room_name = nil
local cached_enemy = ""

-- =============================================================================
-- Combat tracking state
-- =============================================================================
local in_combat = false
local death_flag = false
local fight_start = nil     -- Snapshot at combat start: {time, tnl, gold, level, zone, room_num, room_name, enemy}
local damage_total = 0      -- Accumulated damage from [damage] lines this fight
local round_count = 0       -- Number of enemypct changes this fight
local last_enemypct = nil   -- For dedup of multiple char.status per round

-- =============================================================================
-- Database helpers (following aard_GMCP_mapper.xml patterns)
-- =============================================================================
local function dbcheck(code, msg, query)
   if code ~= sqlite3.OK and
      code ~= sqlite3.ROW and
      code ~= sqlite3.DONE then
      local err = (msg or "unknown") .. "\nCODE: " .. (code or "?") .. "\nQUERY: " .. (query or "?")
      if db then db:exec("ROLLBACK") end
      ColourNote("red", "", PREFIX .. "SQL Error: " .. err)
      return true  -- error occurred
   end
   return false  -- no error
end

local function fixsql(s)
   if s then
      return "'" .. (string.gsub(s, "'", "''")) .. "'"
   else
      return "NULL"
   end
end

-- =============================================================================
-- Schema management
-- =============================================================================
local function get_schema_version()
   -- Check if schema_version table exists
   local found = false
   for row in db:nrows("SELECT name FROM sqlite_master WHERE type='table' AND name='schema_version'") do
      found = true
   end
   if not found then return 0 end

   local version = 0
   for row in db:nrows("SELECT version FROM schema_version LIMIT 1") do
      version = row.version
   end
   return version
end

local function set_schema_version(version)
   db:exec("DELETE FROM schema_version")
   db:exec(string.format("INSERT INTO schema_version (version) VALUES (%d)", version))
end

local function migrate_to_v1()
   local sql = [[
      CREATE TABLE IF NOT EXISTS schema_version (
         version INTEGER NOT NULL
      );

      CREATE TABLE IF NOT EXISTS kills (
         id          INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp   INTEGER NOT NULL,
         mob_name    TEXT NOT NULL,
         zone        TEXT NOT NULL,
         room_num    INTEGER,
         room_name   TEXT,
         level       INTEGER NOT NULL,
         xp_gained   INTEGER NOT NULL DEFAULT 0,
         gold_gained INTEGER NOT NULL DEFAULT 0,
         damage_total INTEGER NOT NULL DEFAULT 0,
         rounds      INTEGER NOT NULL DEFAULT 0,
         duration    INTEGER NOT NULL DEFAULT 0
      );

      CREATE TABLE IF NOT EXISTS deaths (
         id          INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp   INTEGER NOT NULL,
         mob_name    TEXT,
         zone        TEXT NOT NULL,
         room_num    INTEGER,
         room_name   TEXT,
         level       INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_kills_level ON kills(level);
      CREATE INDEX IF NOT EXISTS idx_kills_zone ON kills(zone);
      CREATE INDEX IF NOT EXISTS idx_kills_mob ON kills(mob_name);
      CREATE INDEX IF NOT EXISTS idx_kills_timestamp ON kills(timestamp);
      CREATE INDEX IF NOT EXISTS idx_deaths_level ON deaths(level);
      CREATE INDEX IF NOT EXISTS idx_deaths_zone ON deaths(zone);
   ]]
   db:exec(sql)
   if dbcheck(db:errcode(), db:errmsg(), "migrate_to_v1") then return false end
   set_schema_version(1)
   return true
end

local function run_migrations()
   local version = get_schema_version()

   if version < 1 then
      if not migrate_to_v1() then
         ColourNote("red", "", PREFIX .. "Migration to v1 failed!")
         return false
      end
   end

   -- Future migrations go here:
   -- if version < 2 then migrate_to_v2() end

   return true
end

-- =============================================================================
-- Database open/close
-- =============================================================================
local function close_db()
   if db then
      db:close()
      db = nil
      db_filename = nil
      db_path = nil
   end
end

local function open_db(tier, remort)
   close_db()

   local filename = string.format("ldb_T%dR%d.db", tier, remort)
   local path = GetInfo(66) .. filename

   local handle, err_msg, err_code = sqlite3.open(path)
   if not handle then
      ColourNote("red", "", PREFIX .. "Failed to open database: " .. (err_msg or "unknown error"))
      return false
   end

   db = handle
   db_filename = filename
   db_path = path

   -- Enable WAL mode for better concurrent read/write
   db:exec("PRAGMA journal_mode=WAL;")

   -- Run schema migrations
   if not run_migrations() then
      close_db()
      return false
   end

   return true
end

-- =============================================================================
-- Database switching (on tier/remort change)
-- =============================================================================
local function detect_and_switch_db()
   local base = gmcp("char.base")
   if not base then return false end

   local tier = tonumber(base.tier)
   local remorts = tonumber(base.remorts)
   local perlevel = tonumber(base.perlevel)

   if not tier or not remorts then return false end

   -- Update perlevel cache
   if perlevel then cached_perlevel = perlevel end

   -- Check if DB switch is needed
   if tier == cached_tier and remorts == cached_remorts and db then
      return true  -- Already on correct DB
   end

   cached_tier = tier
   cached_remorts = remorts

   if open_db(tier, remorts) then
      ColourNote("cyan", "", PREFIX .. "Database: " .. db_filename)
      return true
   end

   return false
end

-- =============================================================================
-- Combat state management
-- =============================================================================
local function start_fight(enemy_name)
   in_combat = true
   death_flag = false
   damage_total = 0
   round_count = 0
   last_enemypct = nil

   fight_start = {
      time = os.time(),
      tnl = cached_tnl,
      gold = cached_gold,
      level = cached_level,
      zone = cached_zone or "Unknown",
      room_num = cached_room_num,
      room_name = cached_room_name,
      enemy = enemy_name,
   }
end

local function record_kill()
   if not fight_start then return end
   if not db then return end
   if not enabled then return end

   -- Calculate XP gained
   local xp_gained = 0
   if fight_start.tnl and cached_tnl and fight_start.level and cached_level then
      if cached_level > fight_start.level then
         -- Leveled up during combat
         xp_gained = fight_start.tnl + (cached_perlevel - cached_tnl)
      elseif cached_level == fight_start.level then
         -- Normal kill
         xp_gained = fight_start.tnl - cached_tnl
      end
      -- If xp_gained < 0, something unexpected happened (quest XP, etc.) â€” clamp to 0
      if xp_gained < 0 then xp_gained = 0 end
   end

   -- Calculate gold gained
   local gold_gained = 0
   if fight_start.gold and cached_gold then
      gold_gained = cached_gold - fight_start.gold
      -- Gold can go negative if player spent gold during combat (shops, etc.)
      -- Record as-is for accuracy
   end

   -- Calculate duration
   local duration = os.time() - fight_start.time

   -- INSERT kill record
   local query = string.format(
      "INSERT INTO kills (timestamp, mob_name, zone, room_num, room_name, level, xp_gained, gold_gained, damage_total, rounds, duration) " ..
      "VALUES (%d, %s, %s, %s, %s, %d, %d, %d, %d, %d, %d)",
      os.time(),
      fixsql(fight_start.enemy),
      fixsql(fight_start.zone),
      fight_start.room_num and tostring(fight_start.room_num) or "NULL",
      fixsql(fight_start.room_name),
      fight_start.level or 0,
      xp_gained,
      gold_gained,
      damage_total,
      round_count,
      duration
   )

   db:exec(query)
   dbcheck(db:errcode(), db:errmsg(), query)
end

local function record_death()
   if not db then return end
   if not enabled then return end

   local enemy = (in_combat and fight_start) and fight_start.enemy or cached_enemy

   local query = string.format(
      "INSERT INTO deaths (timestamp, mob_name, zone, room_num, room_name, level) " ..
      "VALUES (%d, %s, %s, %s, %s, %d)",
      os.time(),
      fixsql(enemy),
      fixsql(cached_zone or "Unknown"),
      cached_room_num and tostring(cached_room_num) or "NULL",
      fixsql(cached_room_name),
      cached_level or 0
   )

   db:exec(query)
   dbcheck(db:errcode(), db:errmsg(), query)
end

local function end_combat()
   in_combat = false
   fight_start = nil
   damage_total = 0
   round_count = 0
   last_enemypct = nil
end

-- =============================================================================
-- GMCP broadcast handler
-- =============================================================================
function OnPluginBroadcast(msg, id, name, text)
   if id ~= GMCP_HANDLER_ID then return end

   if text == "char.base" then
      local base = gmcp("char.base")
      if base then
         if base.perlevel then cached_perlevel = tonumber(base.perlevel) or 1000 end
         -- Detect tier/remort change and switch DB
         local new_tier = tonumber(base.tier)
         local new_remorts = tonumber(base.remorts)
         if new_tier and new_remorts then
            if new_tier ~= cached_tier or new_remorts ~= cached_remorts then
               detect_and_switch_db()
            end
         end
      end

   elseif text == "char.status" then
      local status = gmcp("char.status")
      if not status then return end

      -- Update cached values
      local new_level = tonumber(status.level)
      local new_tnl = tonumber(status.tnl)
      if new_level and new_level ~= -1 then cached_level = new_level end
      if new_tnl and new_tnl ~= -1 then cached_tnl = new_tnl end

      local new_enemy = status.enemy or ""

      -- State machine transitions
      if not enabled then
         cached_enemy = new_enemy
         return
      end

      if not in_combat then
         -- IDLE state
         if new_enemy ~= "" then
            -- Transition 1: IDLE --> COMBAT
            start_fight(new_enemy)
         end
      else
         -- COMBAT state
         if death_flag then
            -- Already processed death, ignore subsequent GMCP updates
            if new_enemy == "" then
               end_combat()
            end
            cached_enemy = new_enemy
            return
         end

         if new_enemy == "" then
            -- Transition 3: COMBAT --> KILL_RECORDED --> IDLE
            record_kill()
            end_combat()

         elseif new_enemy ~= cached_enemy and cached_enemy ~= "" then
            -- Transition 4: COMBAT --> KILL_RECORDED --> COMBAT (enemy switch)
            record_kill()
            start_fight(new_enemy)

         else
            -- Transition 2: COMBAT --> COMBAT (same enemy, check round)
            local new_pct = tonumber(status.enemypct)
            if new_pct and new_pct ~= last_enemypct then
               round_count = round_count + 1
               last_enemypct = new_pct
            end
         end
      end

      cached_enemy = new_enemy

   elseif text == "char.worth" then
      local worth = gmcp("char.worth")
      if worth then
         local new_gold = tonumber(worth.gold)
         if new_gold then cached_gold = new_gold end
      end

   elseif text == "room.info" then
      local room = gmcp("room.info")
      if room then
         cached_zone = room.zone
         cached_room_num = tonumber(room.num)
         cached_room_name = room.name
      end
   end
end

-- =============================================================================
-- Text trigger handlers
-- =============================================================================
function ldb_on_damage_line(name, line, wildcards)
   if not in_combat then return end
   if not enabled then return end

   -- wildcards[1] = damage value (from trailing [N])
   local dmg = tonumber(wildcards[1])
   if dmg then
      damage_total = damage_total + dmg
   end
end

function ldb_on_player_death(name, line, wildcards)
   if not enabled then return end

   death_flag = true
   record_death()

   -- Don't end_combat() yet -- wait for GMCP enemy="" to clean up properly
   -- The death_flag prevents record_kill() from firing
end

-- =============================================================================
-- Helper: format number with commas
-- =============================================================================
local function format_number(n)
   local formatted = tostring(n)
   while true do
      local k
      formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
      if k == 0 then break end
   end
   return formatted
end

-- =============================================================================
-- Helper: format duration (seconds) to human-readable
-- =============================================================================
local function format_duration(secs)
   if secs < 60 then
      return secs .. "s"
   elseif secs < 3600 then
      return string.format("%dm %ds", math.floor(secs / 60), secs % 60)
   else
      return string.format("%dh %dm %ds", math.floor(secs / 3600), math.floor((secs % 3600) / 60), secs % 60)
   end
end

-- =============================================================================
-- Helper: check DB is available for queries
-- =============================================================================
local function require_db()
   if not db then
      ColourNote("red", "", PREFIX .. "No database open. Make sure you are connected to Aardwolf.")
      return false
   end
   return true
end

-- =============================================================================
-- Command: ldb (status)
-- =============================================================================
function ldb_status(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Status")
   ColourNote("cyan", "", "  Enabled: " .. (enabled and "ON" or "OFF"))
   ColourNote("cyan", "", "  Database: " .. (db_filename or "(none)"))

   if db then
      local kill_count = 0
      local death_count = 0
      for row in db:nrows("SELECT COUNT(*) as cnt FROM kills WHERE xp_gained > 0") do
         kill_count = row.cnt
      end
      for row in db:nrows("SELECT COUNT(*) as cnt FROM deaths") do
         death_count = row.cnt
      end
      ColourNote("cyan", "", "  Kills recorded: " .. format_number(kill_count))
      ColourNote("cyan", "", "  Deaths recorded: " .. format_number(death_count))
   end

   if cached_level then
      ColourNote("cyan", "", "  Current level: " .. cached_level)
   end
   if cached_zone then
      ColourNote("cyan", "", "  Current zone: " .. cached_zone)
   end
   if in_combat and fight_start then
      ColourNote("cyan", "", "  In combat: " .. fight_start.enemy .. " (round " .. round_count .. ", dmg " .. format_number(damage_total) .. ")")
   end
end

-- =============================================================================
-- Command: ldb help
-- =============================================================================
function ldb_help(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Commands:")
   ColourNote("cyan", "", "  ldb                     - Show status")
   ColourNote("cyan", "", "  ldb help                - Show this help")
   ColourNote("cyan", "", "  ldb on / off            - Enable/disable data collection")
   ColourNote("cyan", "", "  ldb level [N]           - Kill breakdown for level N (default: current)")
   ColourNote("cyan", "", "  ldb zone [name]         - Stats for a zone (default: current)")
   ColourNote("cyan", "", "  ldb mob <name>          - Stats for a mob (substring match)")
   ColourNote("cyan", "", "  ldb top mobs [N]        - Top N mobs by kill count (default 10)")
   ColourNote("cyan", "", "  ldb top zones [N]       - Top N zones by total XP (default 10)")
   ColourNote("cyan", "", "  ldb top xp [N]          - Top N mobs by avg XP per kill (default 10)")
   ColourNote("cyan", "", "  ldb deaths [N]          - Last N deaths (default 10)")
   ColourNote("cyan", "", "  ldb db                  - Database file info")
   ColourNote("cyan", "", "  ldb db list             - List all database files")
   ColourNote("cyan", "", "  ldb db switch           - Force re-detect tier/remort")
end

-- =============================================================================
-- Command: ldb on / ldb off
-- =============================================================================
function ldb_on(name, line, wildcards)
   enabled = true
   if not db then
      detect_and_switch_db()
   end
   ColourNote("cyan", "", PREFIX .. "Data collection enabled" .. (db_filename and (" (" .. db_filename .. ")") or ""))
end

function ldb_off(name, line, wildcards)
   enabled = false
   ColourNote("cyan", "", PREFIX .. "Data collection disabled")
end

-- =============================================================================
-- Command: ldb level [N]
-- =============================================================================
function ldb_level_current(name, line, wildcards)
   if not require_db() then return end
   local level = cached_level
   if not level then
      ColourNote("red", "", PREFIX .. "Current level unknown. Try again after GMCP data arrives.")
      return
   end
   show_level_stats(level)
end

function ldb_level(name, line, wildcards)
   if not require_db() then return end
   local level = tonumber(wildcards[1])
   if not level then
      ColourNote("red", "", PREFIX .. "Invalid level number.")
      return
   end
   show_level_stats(level)
end

function show_level_stats(level)
   ColourNote("cyan", "", PREFIX .. "Level " .. level .. " breakdown:")

   -- Summary
   local total_kills = 0
   local total_xp = 0
   local total_gold = 0
   local total_damage = 0
   local total_duration = 0
   local total_rounds = 0
   local total_deaths = 0

   for row in db:nrows(string.format(
      "SELECT COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, COALESCE(SUM(gold_gained), 0) as gold, " ..
      "COALESCE(SUM(damage_total), 0) as dmg, COALESCE(SUM(duration), 0) as dur, COALESCE(SUM(rounds), 0) as rnd " ..
      "FROM kills WHERE level = %d AND xp_gained > 0", level)) do
      total_kills = row.cnt
      total_xp = row.xp
      total_gold = row.gold
      total_damage = row.dmg
      total_duration = row.dur
      total_rounds = row.rnd
   end

   for row in db:nrows(string.format("SELECT COUNT(*) as cnt FROM deaths WHERE level = %d", level)) do
      total_deaths = row.cnt
   end

   if total_kills == 0 then
      ColourNote("yellow", "", "  No kills recorded at this level.")
      if total_deaths > 0 then
         ColourNote("red", "", "  Deaths: " .. total_deaths)
      end
      return
   end

   ColourNote("white", "", string.format("  Kills: %s | XP: %s | Gold: %s",
      format_number(total_kills), format_number(total_xp), format_number(total_gold)))
   ColourNote("white", "", string.format("  Damage: %s | Rounds: %s | Time: %s",
      format_number(total_damage), format_number(total_rounds), format_duration(total_duration)))

   local avg_xp = total_kills > 0 and math.floor(total_xp / total_kills) or 0
   local avg_dur = total_kills > 0 and math.floor(total_duration / total_kills) or 0
   ColourNote("white", "", string.format("  Avg XP/kill: %s | Avg duration: %s",
      format_number(avg_xp), format_duration(avg_dur)))

   if total_deaths > 0 then
      ColourNote("red", "", "  Deaths: " .. total_deaths)
   end

   -- Top mobs at this level
   ColourNote("cyan", "", "  Top mobs:")
   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE level = %d AND xp_gained > 0 " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT 5", level)) do
      count = count + 1
      ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
         count, row.mob_name, row.cnt, format_number(row.xp)))
   end

   -- Zones at this level
   ColourNote("cyan", "", "  Zones:")
   count = 0
   for row in db:nrows(string.format(
      "SELECT zone, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE level = %d AND xp_gained > 0 " ..
      "GROUP BY zone ORDER BY xp DESC LIMIT 5", level)) do
      count = count + 1
      ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
         count, row.zone, row.cnt, format_number(row.xp)))
   end
end

-- =============================================================================
-- Command: ldb zone [name]
-- =============================================================================
function ldb_zone_current(name, line, wildcards)
   if not require_db() then return end
   local zone = cached_zone
   if not zone then
      ColourNote("red", "", PREFIX .. "Current zone unknown. Try again after GMCP data arrives.")
      return
   end
   show_zone_stats(zone)
end

function ldb_zone(name, line, wildcards)
   if not require_db() then return end
   show_zone_stats(wildcards[1])
end

function show_zone_stats(zone_name)
   -- Use LIKE for flexible matching
   local like_pattern = "%" .. zone_name .. "%"

   -- Find matching zones
   local zones_found = {}
   for row in db:nrows(string.format(
      "SELECT DISTINCT zone FROM kills WHERE zone LIKE %s", fixsql(like_pattern))) do
      table.insert(zones_found, row.zone)
   end

   if #zones_found == 0 then
      ColourNote("yellow", "", PREFIX .. "No kills recorded in zones matching '" .. zone_name .. "'.")
      return
   end

   for _, zone in ipairs(zones_found) do
      ColourNote("cyan", "", PREFIX .. "Zone: " .. zone)

      for row in db:nrows(string.format(
         "SELECT COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, COALESCE(SUM(gold_gained), 0) as gold, " ..
         "COALESCE(SUM(damage_total), 0) as dmg, COALESCE(SUM(duration), 0) as dur, COALESCE(SUM(rounds), 0) as rnd " ..
         "FROM kills WHERE zone = %s AND xp_gained > 0", fixsql(zone))) do

         if row.cnt > 0 then
            ColourNote("white", "", string.format("  Kills: %s | XP: %s | Gold: %s",
               format_number(row.cnt), format_number(row.xp), format_number(row.gold)))

            local avg_xp = math.floor(row.xp / row.cnt)
            local avg_dur = math.floor(row.dur / row.cnt)
            ColourNote("white", "", string.format("  Avg XP/kill: %s | Avg duration: %s",
               format_number(avg_xp), format_duration(avg_dur)))
         end
      end

      -- Deaths in this zone
      for row in db:nrows(string.format(
         "SELECT COUNT(*) as cnt FROM deaths WHERE zone = %s", fixsql(zone))) do
         if row.cnt > 0 then
            ColourNote("red", "", "  Deaths: " .. row.cnt)
         end
      end

      -- Level range
      for row in db:nrows(string.format(
         "SELECT MIN(level) as min_lvl, MAX(level) as max_lvl " ..
         "FROM kills WHERE zone = %s AND xp_gained > 0", fixsql(zone))) do
         if row.min_lvl then
            ColourNote("white", "", string.format("  Level range: %d - %d", row.min_lvl, row.max_lvl))
         end
      end

      -- Top mobs
      ColourNote("cyan", "", "  Top mobs:")
      local count = 0
      for row in db:nrows(string.format(
         "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
         "FROM kills WHERE zone = %s AND xp_gained > 0 " ..
         "GROUP BY mob_name ORDER BY cnt DESC LIMIT 5", fixsql(zone))) do
         count = count + 1
         ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
            count, row.mob_name, row.cnt, format_number(row.xp)))
      end
   end
end

-- =============================================================================
-- Command: ldb mob <name>
-- =============================================================================
function ldb_mob(name, line, wildcards)
   if not require_db() then return end
   local mob_search = wildcards[1]
   local like_pattern = "%" .. mob_search .. "%"

   ColourNote("cyan", "", PREFIX .. "Mob search: " .. mob_search)

   local found = false
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, " ..
      "COALESCE(SUM(gold_gained), 0) as gold, COALESCE(SUM(damage_total), 0) as dmg, " ..
      "COALESCE(SUM(duration), 0) as dur, COALESCE(SUM(rounds), 0) as rnd " ..
      "FROM kills WHERE mob_name LIKE %s AND xp_gained > 0 " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT 10", fixsql(like_pattern))) do

      found = true
      ColourNote("white", "", string.format("  %s: %d kills, %s XP, %s gold",
         row.mob_name, row.cnt, format_number(row.xp), format_number(row.gold)))

      local avg_xp = math.floor(row.xp / row.cnt)
      local avg_dur = math.floor(row.dur / row.cnt)
      local avg_rnd = row.cnt > 0 and string.format("%.1f", row.rnd / row.cnt) or "0"
      ColourNote("white", "", string.format("    Avg XP: %s | Avg duration: %s | Avg rounds: %s",
         format_number(avg_xp), format_duration(avg_dur), avg_rnd))

      -- Zones where this mob was killed
      local zones = {}
      for zrow in db:nrows(string.format(
         "SELECT DISTINCT zone FROM kills WHERE mob_name = %s AND xp_gained > 0",
         fixsql(row.mob_name))) do
         table.insert(zones, zrow.zone)
      end
      if #zones > 0 then
         ColourNote("white", "", "    Zones: " .. table.concat(zones, ", "))
      end
   end

   if not found then
      ColourNote("yellow", "", "  No kills found matching '" .. mob_search .. "'.")
   end
end

-- =============================================================================
-- Command: ldb top mobs [N]
-- =============================================================================
function ldb_top_mobs_default(name, line, wildcards)
   if not require_db() then return end
   show_top_mobs(10)
end

function ldb_top_mobs(name, line, wildcards)
   if not require_db() then return end
   show_top_mobs(tonumber(wildcards[1]) or 10)
end

function show_top_mobs(limit)
   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " mobs by kill count:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE xp_gained > 0 " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (%d kills, %s XP)",
         count, row.mob_name, row.cnt, format_number(row.xp)))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb top zones [N]
-- =============================================================================
function ldb_top_zones_default(name, line, wildcards)
   if not require_db() then return end
   show_top_zones(10)
end

function ldb_top_zones(name, line, wildcards)
   if not require_db() then return end
   show_top_zones(tonumber(wildcards[1]) or 10)
end

function show_top_zones(limit)
   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " zones by total XP:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT zone, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE xp_gained > 0 " ..
      "GROUP BY zone ORDER BY xp DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (%d kills, %s XP)",
         count, row.zone, row.cnt, format_number(row.xp)))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb top xp [N]
-- =============================================================================
function ldb_top_xp_default(name, line, wildcards)
   if not require_db() then return end
   show_top_xp(10)
end

function ldb_top_xp(name, line, wildcards)
   if not require_db() then return end
   show_top_xp(tonumber(wildcards[1]) or 10)
end

function show_top_xp(limit)
   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " mobs by avg XP per kill:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp, " ..
      "CAST(SUM(xp_gained) AS REAL) / COUNT(*) as avg_xp " ..
      "FROM kills WHERE xp_gained > 0 " ..
      "GROUP BY mob_name HAVING cnt >= 3 " ..
      "ORDER BY avg_xp DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (avg %s XP, %d kills)",
         count, row.mob_name, format_number(math.floor(row.avg_xp)), row.cnt))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No mobs with 3+ kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb deaths [N]
-- =============================================================================
function ldb_deaths_default(name, line, wildcards)
   if not require_db() then return end
   show_deaths(10)
end

function ldb_deaths(name, line, wildcards)
   if not require_db() then return end
   show_deaths(tonumber(wildcards[1]) or 10)
end

function show_deaths(limit)
   ColourNote("cyan", "", PREFIX .. "Last " .. limit .. " deaths:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT timestamp, mob_name, zone, level FROM deaths " ..
      "ORDER BY timestamp DESC LIMIT %d", limit)) do
      count = count + 1
      local time_str = os.date("%Y-%m-%d %H:%M", row.timestamp)
      local mob = row.mob_name or "unknown"
      ColourNote("white", "", string.format("  %s - Lvl %d - %s (%s)",
         time_str, row.level, mob, row.zone))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No deaths recorded.")
   end
end

-- =============================================================================
-- Command: ldb db
-- =============================================================================
function ldb_db_info(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Database info:")
   ColourNote("white", "", "  File: " .. (db_filename or "(none)"))
   ColourNote("white", "", "  Path: " .. (db_path or "(none)"))

   if not db then
      ColourNote("yellow", "", "  Database not open.")
      return
   end

   -- File size
   local f = io.open(db_path, "r")
   if f then
      local size = f:seek("end")
      f:close()
      if size < 1024 then
         ColourNote("white", "", "  Size: " .. size .. " bytes")
      elseif size < 1024 * 1024 then
         ColourNote("white", "", string.format("  Size: %.1f KB", size / 1024))
      else
         ColourNote("white", "", string.format("  Size: %.1f MB", size / (1024 * 1024)))
      end
   end

   -- Record counts
   for row in db:nrows("SELECT COUNT(*) as cnt FROM kills") do
      ColourNote("white", "", "  Total combat records: " .. format_number(row.cnt))
   end
   for row in db:nrows("SELECT COUNT(*) as cnt FROM kills WHERE xp_gained > 0") do
      ColourNote("white", "", "  Confirmed kills: " .. format_number(row.cnt))
   end
   for row in db:nrows("SELECT COUNT(*) as cnt FROM deaths") do
      ColourNote("white", "", "  Deaths: " .. format_number(row.cnt))
   end

   -- Schema version
   ColourNote("white", "", "  Schema version: " .. get_schema_version())
end

-- =============================================================================
-- Command: ldb db list
-- =============================================================================
function ldb_db_list(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Database files:")

   local base_path = GetInfo(66)
   local found = false

   -- Scan for ldb_T*R*.db files
   for tier = 0, 9 do
      for remort = 0, 6 do
         local filename = string.format("ldb_T%dR%d.db", tier, remort)
         local filepath = base_path .. filename
         local f = io.open(filepath, "r")
         if f then
            found = true
            local size = f:seek("end")
            f:close()

            local size_str
            if size < 1024 then
               size_str = size .. " B"
            elseif size < 1024 * 1024 then
               size_str = string.format("%.1f KB", size / 1024)
            else
               size_str = string.format("%.1f MB", size / (1024 * 1024))
            end

            local marker = (filename == db_filename) and " <-- active" or ""
            ColourNote("white", "", string.format("  %s (%s)%s", filename, size_str, marker))
         end
      end
   end

   if not found then
      ColourNote("yellow", "", "  No database files found.")
   end
end

-- =============================================================================
-- Command: ldb db switch
-- =============================================================================
function ldb_db_switch(name, line, wildcards)
   if detect_and_switch_db() then
      ColourNote("cyan", "", PREFIX .. "Database switched to: " .. (db_filename or "(none)"))
   else
      ColourNote("red", "", PREFIX .. "Failed to switch database. GMCP char.base data may not be available yet.")
   end
end

-- =============================================================================
-- Plugin lifecycle
-- =============================================================================
function OnPluginInstall()
   enabled = (GetVariable("enabled") == "true")

   -- Try to open the database immediately from GMCP data
   detect_and_switch_db()

   if enabled then
      ColourNote("cyan", "", PREFIX .. "Loaded (enabled). Database: " .. (db_filename or "(waiting for GMCP)"))
   else
      ColourNote("cyan", "", PREFIX .. "Loaded (disabled). Use 'ldb on' to start collecting data.")
   end
end

function OnPluginSaveState()
   SetVariable("enabled", tostring(enabled))
end

function OnPluginClose()
   close_db()
end

function OnPluginDisconnect()
   -- End any active combat tracking on disconnect
   if in_combat then
      end_combat()
   end
end
]]>
</script>
</muclient>
