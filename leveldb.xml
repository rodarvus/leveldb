<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Plugin "leveldb" - A leveling database for Aardwolf -->

<muclient>
<plugin
   name="leveldb"
   author="Rodarvus"
   id="b34c04e52c6c7bced4508230"
   language="Lua"
   purpose="A simple leveling database for Aardwolf"
   date_written="2026-02-17 08:09:56"
   requires="5.07"
   version="4.0"
   save_state="y"
   >

</plugin>


<!--  Aliases  -->

<aliases>
   <alias
      match="^ldb$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_status"
   ></alias>
   <alias
      match="^ldb help$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_help"
   ></alias>
   <alias
      match="^ldb on$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_on"
   ></alias>
   <alias
      match="^ldb off$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_off"
   ></alias>
   <alias
      match="^ldb level(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_level"
   ></alias>
   <alias
      match="^ldb this$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_thislevel"
   ></alias>
   <alias
      match="^ldb last$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_lastlevel"
   ></alias>
   <alias
      match="^ldb zone(?: (.+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_zone"
   ></alias>
   <alias
      match="^ldb mob (.+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_mob"
   ></alias>
   <alias
      match="^ldb top mobs(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_mobs"
   ></alias>
   <alias
      match="^ldb top zones(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_zones"
   ></alias>
   <alias
      match="^ldb top xp(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_xp"
   ></alias>
   <alias
      match="^ldb deaths(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_deaths"
   ></alias>
   <alias
      match="^ldb db$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_db_info"
   ></alias>
</aliases>


<!-- Triggers -->

<triggers>
   <!-- Player damage line: [optional hits] Your spell VERB mob. [damage] -->
   <!-- Optional leading * for crits, optional [N] hits prefix, must start with "Your" -->
   <!-- Mob damage to player uses possessive mob name, not "Your", so won't match -->
   <trigger
      match="^\*?(?:\[\d+\] )?Your .+[.!] \[(\d+)\]\*?$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_damage_line"
      sequence="100"
   ></trigger>

   <!-- Player death -->
   <trigger
      match="^You die\.$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_player_death"
      sequence="100"
   ></trigger>

   <!-- Sacrifice message: deity gives gold for corpse. Mob level = gold * 2 -->
   <trigger
      match="^.+ gives you (\d+) gold coins? for .*\.$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_sacrifice"
      sequence="100"
   ></trigger>
</triggers>


<script>
<![CDATA[
require "gmcphelper"

-- =============================================================================
-- Constants
-- =============================================================================
local GMCP_HANDLER_ID = "3e7dedbe37e44942dd46d264"
local DB_DIR = "state\\leveldb\\"
local DB_FILENAME = "leveldb.db"
local PREFIX = "[LevelDB] "

-- =============================================================================
-- Plugin state (persisted via save_state)
-- =============================================================================
local enabled = false

-- =============================================================================
-- Database state
-- =============================================================================
local db = nil              -- SQLite database handle
local db_path = nil         -- Full path to database

-- =============================================================================
-- GMCP cached values (updated on each broadcast)
-- =============================================================================
local cached_tier = nil
local cached_remorts = nil
local cached_pups = nil
local cached_perlevel = 1000
local cached_level = nil
local cached_tnl = nil
local cached_zone = nil
local cached_room_num = nil
local cached_room_name = nil
local cached_enemy = ""

-- =============================================================================
-- Combat tracking state
-- =============================================================================
local in_combat = false
local death_flag = false
local fight_start = nil     -- Snapshot at combat start: {tnl, level, zone, room_num, room_name, enemy, pup}
local damage_total = 0      -- Accumulated damage from [damage] lines this fight
local round_count = 0       -- Number of enemypct changes this fight
local last_enemypct = nil   -- For dedup of multiple char.status per round
local sacrifice_mob_level = nil  -- Estimated mob level from sacrifice gold * 2

-- =============================================================================
-- Database helpers (following aard_GMCP_mapper.xml patterns)
-- =============================================================================
local function dbcheck(code, msg, query)
   if code ~= sqlite3.OK and
      code ~= sqlite3.ROW and
      code ~= sqlite3.DONE then
      local err = (msg or "unknown") .. "\nCODE: " .. (code or "?") .. "\nQUERY: " .. (query or "?")
      if db then db:exec("ROLLBACK") end
      ColourNote("red", "", PREFIX .. "SQL Error: " .. err)
      return true  -- error occurred
   end
   return false  -- no error
end

local function fixsql(s)
   if s then
      return "'" .. (string.gsub(s, "'", "''")) .. "'"
   else
      return "NULL"
   end
end

-- =============================================================================
-- Schema initialization (split into tables, migrations, indexes)
-- =============================================================================
local function init_tables()
   local sql = [[
      CREATE TABLE IF NOT EXISTS kills (
         id           INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp    INTEGER NOT NULL,
         mob_name     TEXT NOT NULL,
         zone         TEXT NOT NULL,
         room_num     INTEGER,
         room_name    TEXT,
         level        INTEGER NOT NULL,
         xp_gained    INTEGER NOT NULL DEFAULT 0,
         damage_total INTEGER NOT NULL DEFAULT 0,
         rounds       INTEGER NOT NULL DEFAULT 0,
         tier         INTEGER,
         remort       INTEGER,
         pup          INTEGER,
         mob_level    INTEGER
      );

      CREATE TABLE IF NOT EXISTS deaths (
         id           INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp    INTEGER NOT NULL,
         mob_name     TEXT,
         zone         TEXT NOT NULL,
         room_num     INTEGER,
         room_name    TEXT,
         level        INTEGER NOT NULL,
         tier         INTEGER,
         remort       INTEGER
      );
   ]]
   db:exec(sql)
   return not dbcheck(db:errcode(), db:errmsg(), "init_tables")
end

local function run_migrations()
   -- Migration: add pup column (v2.0 -> v3.0)
   db:exec("ALTER TABLE kills ADD COLUMN pup INTEGER")
   -- Migration: add mob_level column (v3.0 -> v4.0)
   db:exec("ALTER TABLE kills ADD COLUMN mob_level INTEGER")
   -- Errors from "duplicate column name" are silently ignored
end

local function init_indexes()
   local sql = [[
      CREATE INDEX IF NOT EXISTS idx_kills_level ON kills(level);
      CREATE INDEX IF NOT EXISTS idx_kills_zone ON kills(zone);
      CREATE INDEX IF NOT EXISTS idx_kills_mob ON kills(mob_name);
      CREATE INDEX IF NOT EXISTS idx_kills_timestamp ON kills(timestamp);
      CREATE INDEX IF NOT EXISTS idx_kills_tier ON kills(tier);
      CREATE INDEX IF NOT EXISTS idx_kills_remort ON kills(remort);
      CREATE INDEX IF NOT EXISTS idx_kills_pup ON kills(pup);
      CREATE INDEX IF NOT EXISTS idx_kills_mob_level ON kills(mob_level);
      CREATE INDEX IF NOT EXISTS idx_deaths_level ON deaths(level);
      CREATE INDEX IF NOT EXISTS idx_deaths_zone ON deaths(zone);
      CREATE INDEX IF NOT EXISTS idx_deaths_tier ON deaths(tier);
      CREATE INDEX IF NOT EXISTS idx_deaths_remort ON deaths(remort);
   ]]
   db:exec(sql)
   return not dbcheck(db:errcode(), db:errmsg(), "init_indexes")
end

-- =============================================================================
-- Database open/close
-- =============================================================================
local function close_db()
   if db then
      db:close()
      db = nil
      db_path = nil
   end
end

local function open_db()
   if db then return true end

   local dir = GetInfo(60) .. DB_DIR
   os.execute('if not exist "' .. dir .. '" mkdir "' .. dir .. '"')
   local path = dir .. DB_FILENAME

   local handle, err_msg, err_code = sqlite3.open(path)
   if not handle then
      ColourNote("red", "", PREFIX .. "Failed to open database: " .. (err_msg or "unknown error"))
      return false
   end

   db = handle
   db_path = path

   if not init_tables() then
      close_db()
      return false
   end

   run_migrations()

   if not init_indexes() then
      close_db()
      return false
   end

   return true
end

-- =============================================================================
-- Combat state management
-- =============================================================================
local function start_fight(enemy_name)
   in_combat = true
   death_flag = false
   damage_total = 0
   round_count = 0
   last_enemypct = nil
   sacrifice_mob_level = nil

   fight_start = {
      tnl = cached_tnl,
      level = cached_level,
      zone = cached_zone or "Unknown",
      room_num = cached_room_num,
      room_name = cached_room_name,
      enemy = enemy_name,
      pup = cached_pups,
   }
end

local function record_kill()
   if not fight_start then return end
   if not db then return end
   if not enabled then return end

   -- Calculate XP gained
   local xp_gained = 0
   if fight_start.tnl and cached_tnl and fight_start.level and cached_level then
      if cached_level > fight_start.level then
         -- Leveled up during combat (1-199)
         xp_gained = fight_start.tnl + (cached_perlevel - cached_tnl)
      elseif fight_start.level >= 200 and cached_tnl > fight_start.tnl then
         -- Powerup during combat (200/201: TNL reset without level change)
         xp_gained = fight_start.tnl + (cached_perlevel - cached_tnl)
      elseif cached_level == fight_start.level then
         -- Normal kill (same level/pup, no reset)
         xp_gained = fight_start.tnl - cached_tnl
      end
      if xp_gained < 0 then xp_gained = 0 end
   end

   local query = string.format(
      "INSERT INTO kills (timestamp, mob_name, zone, room_num, room_name, level, " ..
      "xp_gained, damage_total, rounds, tier, remort, pup, mob_level) " ..
      "VALUES (%d, %s, %s, %s, %s, %d, %d, %d, %d, %s, %s, %s, %s)",
      os.time(),
      fixsql(fight_start.enemy),
      fixsql(fight_start.zone),
      fight_start.room_num and tostring(fight_start.room_num) or "NULL",
      fixsql(fight_start.room_name),
      fight_start.level or 0,
      xp_gained,
      damage_total,
      round_count,
      cached_tier and tostring(cached_tier) or "NULL",
      cached_remorts and tostring(cached_remorts) or "NULL",
      fight_start.pup and tostring(fight_start.pup) or "NULL",
      sacrifice_mob_level and tostring(sacrifice_mob_level) or "NULL"
   )

   db:exec(query)
   dbcheck(db:errcode(), db:errmsg(), query)
end

local function record_death()
   if not db then return end
   if not enabled then return end

   local enemy = (in_combat and fight_start) and fight_start.enemy or cached_enemy

   local query = string.format(
      "INSERT INTO deaths (timestamp, mob_name, zone, room_num, room_name, level, tier, remort) " ..
      "VALUES (%d, %s, %s, %s, %s, %d, %s, %s)",
      os.time(),
      fixsql(enemy),
      fixsql(cached_zone or "Unknown"),
      cached_room_num and tostring(cached_room_num) or "NULL",
      fixsql(cached_room_name),
      cached_level or 0,
      cached_tier and tostring(cached_tier) or "NULL",
      cached_remorts and tostring(cached_remorts) or "NULL"
   )

   db:exec(query)
   dbcheck(db:errcode(), db:errmsg(), query)
end

local function end_combat()
   in_combat = false
   fight_start = nil
   damage_total = 0
   round_count = 0
   last_enemypct = nil
   sacrifice_mob_level = nil
end


-- =============================================================================
-- GMCP broadcast handler
-- =============================================================================
function OnPluginBroadcast(msg, id, name, text)
   if id ~= GMCP_HANDLER_ID then return end

   if text == "char.base" then
      local base = gmcp("char.base")
      if base then
         if base.perlevel then cached_perlevel = tonumber(base.perlevel) or 1000 end
         if base.tier then cached_tier = tonumber(base.tier) end
         if base.remorts then cached_remorts = tonumber(base.remorts) end
         if base.pups then cached_pups = tonumber(base.pups) end
      end

   elseif text == "char.status" then
      local status = gmcp("char.status")
      if not status then return end

      -- Update cached values
      local new_level = tonumber(status.level)
      local new_tnl = tonumber(status.tnl)
      if new_level and new_level ~= -1 then cached_level = new_level end
      if new_tnl and new_tnl ~= -1 then cached_tnl = new_tnl end

      local new_enemy = status.enemy or ""

      -- State machine transitions
      if not enabled then
         cached_enemy = new_enemy
         return
      end

      if not in_combat then
         -- IDLE state
         if new_enemy ~= "" then
            -- Transition 1: IDLE --> COMBAT
            start_fight(new_enemy)
         end
      else
         -- COMBAT state
         if death_flag then
            if new_enemy == "" then
               end_combat()
            end
            cached_enemy = new_enemy
            return
         end

         if new_enemy == "" then
            -- Transition 3: COMBAT --> KILL_RECORDED --> IDLE
            record_kill()
            end_combat()

         elseif new_enemy ~= cached_enemy and cached_enemy ~= "" then
            -- Transition 4: COMBAT --> KILL_RECORDED --> COMBAT (enemy switch)
            record_kill()
            start_fight(new_enemy)

         else
            -- Transition 2: COMBAT --> COMBAT (same enemy)
            local new_pct = tonumber(status.enemypct)
            if new_pct and last_enemypct and new_pct > last_enemypct then
               -- Health went UP with same name = previous mob died, new mob engaged
               record_kill()
               start_fight(new_enemy)
            elseif new_pct and new_pct ~= last_enemypct then
               round_count = round_count + 1
               last_enemypct = new_pct
            end
         end
      end

      cached_enemy = new_enemy

   elseif text == "room.info" then
      local room = gmcp("room.info")
      if room then
         cached_zone = room.zone
         cached_room_num = tonumber(room.num)
         cached_room_name = room.name
      end
   end
end

-- =============================================================================
-- Text trigger handlers
-- =============================================================================
function ldb_on_damage_line(name, line, wildcards)
   if not in_combat then return end
   if not enabled then return end

   local dmg = tonumber(wildcards[1])
   if dmg then
      damage_total = damage_total + dmg
   end
end

function ldb_on_player_death(name, line, wildcards)
   if not enabled then return end
   if death_flag then return end  -- Guard against double-fire

   death_flag = true
   record_death()
end

function ldb_on_sacrifice(name, line, wildcards)
   if not enabled then return end

   local gold = tonumber(wildcards[1])
   if gold then
      sacrifice_mob_level = gold * 2
   end
end

-- =============================================================================
-- Helper: format number with commas
-- =============================================================================
local function format_number(n)
   local formatted = tostring(n)
   while true do
      local k
      formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
      if k == 0 then break end
   end
   return formatted
end

-- =============================================================================
-- Helper: check DB is available for queries
-- =============================================================================
local function require_db()
   if not db then
      ColourNote("red", "", PREFIX .. "No database open. Try reloading the plugin.")
      return false
   end
   return true
end

-- =============================================================================
-- Command: ldb (status)
-- =============================================================================
function ldb_status(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Status")
   ColourNote("cyan", "", "  Enabled: " .. (enabled and "ON" or "OFF"))
   ColourNote("cyan", "", "  Database: " .. (db_path or "(none)"))

   if db then
      local kill_count = 0
      local death_count = 0
      for row in db:nrows("SELECT COUNT(*) as cnt FROM kills") do
         kill_count = row.cnt
      end
      for row in db:nrows("SELECT COUNT(*) as cnt FROM deaths") do
         death_count = row.cnt
      end
      ColourNote("cyan", "", "  Kills recorded: " .. format_number(kill_count))
      ColourNote("cyan", "", "  Deaths recorded: " .. format_number(death_count))
   end

   if cached_level then
      ColourNote("cyan", "", "  Current level: " .. cached_level)
      if cached_level >= 200 and cached_pups then
         ColourNote("cyan", "", "  Current powerup: " .. cached_pups)
         if cached_tnl and cached_perlevel then
            ColourNote("cyan", "", "  TNL: " .. cached_tnl .. " / " .. cached_perlevel)
         end
      end
   end
   if cached_zone then
      ColourNote("cyan", "", "  Current zone: " .. cached_zone)
   end
   if in_combat and fight_start then
      ColourNote("cyan", "", "  In combat: " .. fight_start.enemy ..
         " (round " .. round_count .. ", dmg " .. format_number(damage_total) .. ")")
   end
end

-- =============================================================================
-- Command: ldb help
-- =============================================================================
function ldb_help(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Commands:")
   ColourNote("cyan", "", "  ldb                     - Show status")
   ColourNote("cyan", "", "  ldb help                - Show this help")
   ColourNote("cyan", "", "  ldb on / off            - Enable/disable data collection")
   ColourNote("cyan", "", "  ldb level [N]           - Kill breakdown for level N (default: current)")
   ColourNote("cyan", "", "                            At 200+: N is powerup number")
   ColourNote("cyan", "", "  ldb this                - Kill breakdown for current level/powerup")
   ColourNote("cyan", "", "  ldb last                - Kill breakdown for previous level/powerup")
   ColourNote("cyan", "", "  ldb zone [name]         - Stats for a zone (default: current)")
   ColourNote("cyan", "", "  ldb mob <name>          - Stats for a mob (substring match)")
   ColourNote("cyan", "", "  ldb top mobs [N]        - Top N mobs by kill count (default 10)")
   ColourNote("cyan", "", "  ldb top zones [N]       - Top N zones by total XP (default 10)")
   ColourNote("cyan", "", "  ldb top xp [N]          - Top N mobs by avg XP per kill (default 10)")
   ColourNote("cyan", "", "  ldb deaths [N]          - Last N deaths (default 10)")
   ColourNote("cyan", "", "  ldb db                  - Database file info")
end

-- =============================================================================
-- Command: ldb on / ldb off
-- =============================================================================
function ldb_on(name, line, wildcards)
   enabled = true
   if not db then open_db() end
   ColourNote("cyan", "", PREFIX .. "Data collection enabled.")
end

function ldb_off(name, line, wildcards)
   enabled = false
   ColourNote("cyan", "", PREFIX .. "Data collection disabled.")
end

-- =============================================================================
-- Command: ldb level [N]
-- =============================================================================
function ldb_level(name, line, wildcards)
   if not require_db() then return end
   local arg = tonumber(wildcards[1])

   if cached_level and cached_level >= 200 then
      -- Powerup mode: argument is a powerup number (default: current pup)
      local pup = arg or cached_pups
      if not pup then
         ColourNote("red", "", PREFIX .. "Current powerup unknown. Try again after GMCP data arrives.")
         return
      end
      show_level_stats(cached_level, pup)
   else
      -- Normal mode: argument is a level number (default: current level)
      local level = arg or cached_level
      if not level then
         ColourNote("red", "", PREFIX .. "Current level unknown. Try again after GMCP data arrives.")
         return
      end
      show_level_stats(level)
   end
end

-- =============================================================================
-- Command: ldb thislevel
-- =============================================================================
function ldb_thislevel(name, line, wildcards)
   if not require_db() then return end
   if not cached_level then
      ColourNote("red", "", PREFIX .. "Current level unknown. Try again after GMCP data arrives.")
      return
   end
   if cached_level >= 200 then
      if not cached_pups then
         ColourNote("red", "", PREFIX .. "Current powerup unknown. Try again after GMCP data arrives.")
         return
      end
      show_level_stats(cached_level, cached_pups)
   else
      show_level_stats(cached_level)
   end
end

-- =============================================================================
-- Command: ldb lastlevel
-- =============================================================================
function ldb_lastlevel(name, line, wildcards)
   if not require_db() then return end
   if not cached_level then
      ColourNote("red", "", PREFIX .. "Current level unknown. Try again after GMCP data arrives.")
      return
   end
   if cached_level >= 200 then
      if not cached_pups then
         ColourNote("red", "", PREFIX .. "Current powerup unknown. Try again after GMCP data arrives.")
         return
      end
      if cached_pups <= 0 then
         ColourNote("yellow", "", PREFIX .. "No previous powerup.")
         return
      end
      show_level_stats(cached_level, cached_pups - 1)
   else
      if cached_level <= 1 then
         ColourNote("yellow", "", PREFIX .. "No previous level.")
         return
      end
      show_level_stats(cached_level - 1)
   end
end

function show_level_stats(level, pup)
   -- Header adapts for powerup mode
   if pup then
      ColourNote("cyan", "", PREFIX .. "Powerup " .. pup .. " kills:")
   else
      ColourNote("cyan", "", PREFIX .. "Level " .. level .. " kills:")
   end

   -- Build query with optional pup filter
   local kills_query, deaths_query
   if pup then
      kills_query = string.format(
         "SELECT mob_name, zone, xp_gained, damage_total, rounds, mob_level " ..
         "FROM kills WHERE level = %d AND pup = %d ORDER BY timestamp", level, pup)
      deaths_query = string.format(
         "SELECT COUNT(*) as cnt FROM deaths WHERE level = %d", level)
   else
      kills_query = string.format(
         "SELECT mob_name, zone, xp_gained, damage_total, rounds, mob_level " ..
         "FROM kills WHERE level = %d ORDER BY timestamp", level)
      deaths_query = string.format(
         "SELECT COUNT(*) as cnt FROM deaths WHERE level = %d", level)
   end

   -- Collect all kills into a table for column width calculation
   local kills = {}
   for row in db:nrows(kills_query) do
      table.insert(kills, row)
   end

   -- Death count
   local total_deaths = 0
   for row in db:nrows(deaths_query) do
      total_deaths = row.cnt
   end

   local no_kills_msg = pup and "  No kills recorded for this powerup." or "  No kills recorded at this level."
   if #kills == 0 then
      ColourNote("yellow", "", no_kills_msg)
      if total_deaths > 0 then
         ColourNote("red", "", "  Deaths: " .. total_deaths)
      end
      return
   end

   -- Calculate column widths from data
   local max_mob = 3   -- "Mob"
   local max_zone = 4  -- "Zone"
   for _, k in ipairs(kills) do
      if #k.mob_name > max_mob then max_mob = #k.mob_name end
      if #k.zone > max_zone then max_zone = #k.zone end
   end
   -- Cap column widths
   if max_mob > 24 then max_mob = 24 end
   if max_zone > 20 then max_zone = 20 end

   -- Row number width
   local num_w = #tostring(#kills)
   if num_w < 1 then num_w = 1 end

   -- Helper to truncate strings
   local function trunc(s, w)
      if #s > w then return string.sub(s, 1, w - 1) .. "+" else return s end
   end

   -- Header
   local hdr = string.format("  %-" .. num_w .. "s  %-" .. max_mob .. "s  %-" .. max_zone .. "s  %7s  %5s  %3s  %4s",
      "#", "Mob", "Zone", "XP", "Dmg", "Rnd", "MLvl")
   ColourNote("cyan", "", hdr)
   local sep = "  " .. string.rep("-", num_w) .. "  " .. string.rep("-", max_mob) .. "  " ..
      string.rep("-", max_zone) .. "  " .. string.rep("-", 7) .. "  " ..
      string.rep("-", 5) .. "  " .. string.rep("-", 3) .. "  " .. string.rep("-", 4)
   ColourNote("cyan", "", sep)

   -- Data rows and running totals
   local total_xp = 0
   local total_damage = 0
   local total_rounds = 0

   for i, k in ipairs(kills) do
      total_xp = total_xp + k.xp_gained
      total_damage = total_damage + k.damage_total
      total_rounds = total_rounds + k.rounds

      local mlvl_str = k.mob_level and tostring(k.mob_level) or "-"
      local row_str = string.format("  %-" .. num_w .. "d  %-" .. max_mob .. "s  %-" .. max_zone .. "s  %7s  %5s  %3d  %4s",
         i, trunc(k.mob_name, max_mob), trunc(k.zone, max_zone),
         format_number(k.xp_gained),
         format_number(k.damage_total), k.rounds, mlvl_str)
      ColourNote("white", "", row_str)
   end

   -- Footer
   ColourNote("cyan", "", sep)

   local footer_label_w = num_w + 2 + max_mob  -- # col + gap + mob col

   local tot_str = string.format("  %-" .. footer_label_w .. "s  %-" .. max_zone .. "s  %7s  %5s  %3d  %4s",
      string.format("Tot %d kills", #kills), "",
      format_number(total_xp),
      format_number(total_damage), total_rounds, "")
   ColourNote("white", "", tot_str)

   local avg_xp = math.floor(total_xp / #kills)
   local avg_dmg = math.floor(total_damage / #kills)
   local avg_rnd = string.format("%.1f", total_rounds / #kills)
   local avg_str = string.format("  %-" .. footer_label_w .. "s  %-" .. max_zone .. "s  %7s  %5s  %3s  %4s",
      "Avg", "",
      format_number(avg_xp),
      format_number(avg_dmg), avg_rnd, "")
   ColourNote("white", "", avg_str)

   if total_deaths > 0 then
      ColourNote("red", "", "  Deaths: " .. total_deaths)
   end
end

-- =============================================================================
-- Command: ldb zone [name]
-- =============================================================================
function ldb_zone(name, line, wildcards)
   if not require_db() then return end
   local zone_name = wildcards[1]
   if not zone_name or zone_name == "" then
      zone_name = cached_zone
      if not zone_name then
         ColourNote("red", "", PREFIX .. "Current zone unknown. Try again after GMCP data arrives.")
         return
      end
   end
   show_zone_stats(zone_name)
end

function show_zone_stats(zone_name)
   local like_pattern = "%" .. zone_name .. "%"

   local zones_found = {}
   for row in db:nrows(string.format(
      "SELECT DISTINCT zone FROM kills WHERE zone LIKE %s", fixsql(like_pattern))) do
      table.insert(zones_found, row.zone)
   end

   if #zones_found == 0 then
      ColourNote("yellow", "", PREFIX .. "No kills recorded in zones matching '" .. zone_name .. "'.")
      return
   end

   for _, zone in ipairs(zones_found) do
      ColourNote("cyan", "", PREFIX .. "Zone: " .. zone)

      for row in db:nrows(string.format(
         "SELECT COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp " ..
         "FROM kills WHERE zone = %s ", fixsql(zone))) do

         if row.cnt > 0 then
            ColourNote("white", "", string.format("  Kills: %s | XP: %s",
               format_number(row.cnt), format_number(row.xp)))

            local avg_xp = math.floor(row.xp / row.cnt)
            ColourNote("white", "", string.format("  Avg XP/kill: %s", format_number(avg_xp)))
         end
      end

      -- Deaths in this zone
      for row in db:nrows(string.format(
         "SELECT COUNT(*) as cnt FROM deaths WHERE zone = %s", fixsql(zone))) do
         if row.cnt > 0 then
            ColourNote("red", "", "  Deaths: " .. row.cnt)
         end
      end

      -- Level range
      for row in db:nrows(string.format(
         "SELECT MIN(level) as min_lvl, MAX(level) as max_lvl " ..
         "FROM kills WHERE zone = %s ", fixsql(zone))) do
         if row.min_lvl then
            ColourNote("white", "", string.format("  Level range: %d - %d", row.min_lvl, row.max_lvl))
         end
      end

      -- Top mobs
      ColourNote("cyan", "", "  Top mobs:")
      local count = 0
      for row in db:nrows(string.format(
         "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
         "FROM kills WHERE zone = %s " ..
         "GROUP BY mob_name ORDER BY cnt DESC LIMIT 5", fixsql(zone))) do
         count = count + 1
         ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
            count, row.mob_name, row.cnt, format_number(row.xp)))
      end
   end
end

-- =============================================================================
-- Command: ldb mob <name>
-- =============================================================================
function ldb_mob(name, line, wildcards)
   if not require_db() then return end
   local mob_search = wildcards[1]
   local like_pattern = "%" .. mob_search .. "%"

   ColourNote("cyan", "", PREFIX .. "Mob search: " .. mob_search)

   local found = false
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, " ..
      "COALESCE(SUM(damage_total), 0) as dmg, " ..
      "COALESCE(SUM(rounds), 0) as rnd " ..
      "FROM kills WHERE mob_name LIKE %s " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT 10", fixsql(like_pattern))) do

      found = true
      ColourNote("white", "", string.format("  %s: %d kills, %s XP",
         row.mob_name, row.cnt, format_number(row.xp)))

      local avg_xp = math.floor(row.xp / row.cnt)
      local avg_rnd = row.cnt > 0 and string.format("%.1f", row.rnd / row.cnt) or "0"
      ColourNote("white", "", string.format("    Avg XP: %s | Avg rounds: %s",
         format_number(avg_xp), avg_rnd))

      -- Zones where this mob was killed
      local zones = {}
      for zrow in db:nrows(string.format(
         "SELECT DISTINCT zone FROM kills WHERE mob_name = %s ",
         fixsql(row.mob_name))) do
         table.insert(zones, zrow.zone)
      end
      if #zones > 0 then
         ColourNote("white", "", "    Zones: " .. table.concat(zones, ", "))
      end
   end

   if not found then
      ColourNote("yellow", "", "  No kills found matching '" .. mob_search .. "'.")
   end
end

-- =============================================================================
-- Command: ldb top mobs [N]
-- =============================================================================
function ldb_top_mobs(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " mobs by kill count:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (%d kills, %s XP)",
         count, row.mob_name, row.cnt, format_number(row.xp)))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb top zones [N]
-- =============================================================================
function ldb_top_zones(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " zones by total XP:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT zone, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills " ..
      "GROUP BY zone ORDER BY xp DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (%d kills, %s XP)",
         count, row.zone, row.cnt, format_number(row.xp)))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb top xp [N]
-- =============================================================================
function ldb_top_xp(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " mobs by avg XP per kill:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp, " ..
      "CAST(SUM(xp_gained) AS REAL) / COUNT(*) as avg_xp " ..
      "FROM kills " ..
      "GROUP BY mob_name HAVING cnt >= 3 " ..
      "ORDER BY avg_xp DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (avg %s XP, %d kills)",
         count, row.mob_name, format_number(math.floor(row.avg_xp)), row.cnt))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No mobs with 3+ kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb deaths [N]
-- =============================================================================
function ldb_deaths(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Last " .. limit .. " deaths:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT timestamp, mob_name, zone, level FROM deaths " ..
      "ORDER BY timestamp DESC LIMIT %d", limit)) do
      count = count + 1
      local time_str = os.date("%Y-%m-%d %H:%M", row.timestamp)
      local mob = row.mob_name or "unknown"
      ColourNote("white", "", string.format("  %s - Lvl %d - %s (%s)",
         time_str, row.level, mob, row.zone))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No deaths recorded.")
   end
end

-- =============================================================================
-- Command: ldb db
-- =============================================================================
function ldb_db_info(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Database info:")
   ColourNote("white", "", "  Path: " .. (db_path or "(none)"))

   if not db then
      ColourNote("yellow", "", "  Database not open.")
      return
   end

   -- File size
   local f = io.open(db_path, "r")
   if f then
      local size = f:seek("end")
      f:close()
      if size < 1024 then
         ColourNote("white", "", "  Size: " .. size .. " bytes")
      elseif size < 1024 * 1024 then
         ColourNote("white", "", string.format("  Size: %.1f KB", size / 1024))
      else
         ColourNote("white", "", string.format("  Size: %.1f MB", size / (1024 * 1024)))
      end
   end

   -- Record counts
   for row in db:nrows("SELECT COUNT(*) as cnt FROM kills") do
      ColourNote("white", "", "  Kills: " .. format_number(row.cnt))
   end
   for row in db:nrows("SELECT COUNT(*) as cnt FROM deaths") do
      ColourNote("white", "", "  Deaths: " .. format_number(row.cnt))
   end
end

-- =============================================================================
-- Plugin lifecycle
-- =============================================================================
function OnPluginInstall()
   enabled = (GetVariable("enabled") == "true")
   open_db()

   if enabled then
      ColourNote("cyan", "", PREFIX .. "Loaded (enabled).")
   else
      ColourNote("cyan", "", PREFIX .. "Loaded (disabled). Use 'ldb on' to start collecting data.")
   end
end

function OnPluginSaveState()
   SetVariable("enabled", tostring(enabled))
end

function OnPluginClose()
   close_db()
end

function OnPluginDisconnect()
   if in_combat then
      end_combat()
   end
end
]]>
</script>
</muclient>
