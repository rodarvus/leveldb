<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Plugin "leveldb" - A leveling database for Aardwolf -->

<muclient>
<plugin
   name="leveldb"
   author="Rodarvus"
   id="b34c04e52c6c7bced4508230"
   language="Lua"
   purpose="A simple leveling database for Aardwolf"
   date_written="2026-02-17 08:09:56"
   requires="5.07"
   version="2.0"
   save_state="y"
   >

</plugin>


<!--  Aliases  -->

<aliases>
   <alias
      match="^ldb$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_status"
   ></alias>
   <alias
      match="^ldb help$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_help"
   ></alias>
   <alias
      match="^ldb on$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_on"
   ></alias>
   <alias
      match="^ldb off$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_off"
   ></alias>
   <alias
      match="^ldb level(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_level"
   ></alias>
   <alias
      match="^ldb zone(?: (.+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_zone"
   ></alias>
   <alias
      match="^ldb mob (.+)$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_mob"
   ></alias>
   <alias
      match="^ldb top mobs(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_mobs"
   ></alias>
   <alias
      match="^ldb top zones(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_zones"
   ></alias>
   <alias
      match="^ldb top xp(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_top_xp"
   ></alias>
   <alias
      match="^ldb deaths(?: (\d+))?$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_deaths"
   ></alias>
   <alias
      match="^ldb db$"
      enabled="y"
      regexp="y"
      sequence="100"
      script="ldb_db_info"
   ></alias>
</aliases>


<!-- Triggers -->

<triggers>
   <!-- Player damage line: [optional hits] Your spell VERB mob. [damage] -->
   <!-- Optional leading * for crits, optional [N] hits prefix, must start with "Your" -->
   <!-- Mob damage to player uses possessive mob name, not "Your", so won't match -->
   <trigger
      match="^\*?(?:\[\d+\] )?Your .+[.!] \[(\d+)\]\*?$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_damage_line"
      sequence="100"
   ></trigger>

   <!-- Player death -->
   <trigger
      match="^You die\.$"
      enabled="y"
      regexp="y"
      keep_evaluating="y"
      omit_from_output="n"
      script="ldb_on_player_death"
      sequence="100"
   ></trigger>
</triggers>


<script>
<![CDATA[
require "gmcphelper"

-- =============================================================================
-- Constants
-- =============================================================================
local GMCP_HANDLER_ID = "3e7dedbe37e44942dd46d264"
local DB_FILENAME = "leveldb.db"
local PREFIX = "[LevelDB] "

-- =============================================================================
-- Plugin state (persisted via save_state)
-- =============================================================================
local enabled = false

-- =============================================================================
-- Database state
-- =============================================================================
local db = nil              -- SQLite database handle
local db_path = nil         -- Full path to database

-- =============================================================================
-- GMCP cached values (updated on each broadcast)
-- =============================================================================
local cached_tier = nil
local cached_remorts = nil
local cached_perlevel = 1000
local cached_level = nil
local cached_tnl = nil
local cached_gold = nil
local cached_zone = nil
local cached_room_num = nil
local cached_room_name = nil
local cached_enemy = ""

-- =============================================================================
-- Combat tracking state
-- =============================================================================
local in_combat = false
local death_flag = false
local fight_start = nil     -- Snapshot at combat start: {time, tnl, gold, level, zone, room_num, room_name, enemy}
local damage_total = 0      -- Accumulated damage from [damage] lines this fight
local round_count = 0       -- Number of enemypct changes this fight
local last_enemypct = nil   -- For dedup of multiple char.status per round

-- =============================================================================
-- Database helpers (following aard_GMCP_mapper.xml patterns)
-- =============================================================================
local function dbcheck(code, msg, query)
   if code ~= sqlite3.OK and
      code ~= sqlite3.ROW and
      code ~= sqlite3.DONE then
      local err = (msg or "unknown") .. "\nCODE: " .. (code or "?") .. "\nQUERY: " .. (query or "?")
      if db then db:exec("ROLLBACK") end
      ColourNote("red", "", PREFIX .. "SQL Error: " .. err)
      return true  -- error occurred
   end
   return false  -- no error
end

local function fixsql(s)
   if s then
      return "'" .. (string.gsub(s, "'", "''")) .. "'"
   else
      return "NULL"
   end
end

-- =============================================================================
-- Schema initialization
-- =============================================================================
local function init_schema()
   local sql = [[
      CREATE TABLE IF NOT EXISTS kills (
         id           INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp    INTEGER NOT NULL,
         mob_name     TEXT NOT NULL,
         zone         TEXT NOT NULL,
         room_num     INTEGER,
         room_name    TEXT,
         level        INTEGER NOT NULL,
         xp_gained    INTEGER NOT NULL DEFAULT 0,
         gold_gained  INTEGER NOT NULL DEFAULT 0,
         damage_total INTEGER NOT NULL DEFAULT 0,
         rounds       INTEGER NOT NULL DEFAULT 0,
         tier         INTEGER,
         remort       INTEGER
      );

      CREATE TABLE IF NOT EXISTS deaths (
         id           INTEGER PRIMARY KEY AUTOINCREMENT,
         timestamp    INTEGER NOT NULL,
         mob_name     TEXT,
         zone         TEXT NOT NULL,
         room_num     INTEGER,
         room_name    TEXT,
         level        INTEGER NOT NULL,
         tier         INTEGER,
         remort       INTEGER
      );

      CREATE INDEX IF NOT EXISTS idx_kills_level ON kills(level);
      CREATE INDEX IF NOT EXISTS idx_kills_zone ON kills(zone);
      CREATE INDEX IF NOT EXISTS idx_kills_mob ON kills(mob_name);
      CREATE INDEX IF NOT EXISTS idx_kills_timestamp ON kills(timestamp);
      CREATE INDEX IF NOT EXISTS idx_kills_tier ON kills(tier);
      CREATE INDEX IF NOT EXISTS idx_kills_remort ON kills(remort);
      CREATE INDEX IF NOT EXISTS idx_deaths_level ON deaths(level);
      CREATE INDEX IF NOT EXISTS idx_deaths_zone ON deaths(zone);
      CREATE INDEX IF NOT EXISTS idx_deaths_tier ON deaths(tier);
      CREATE INDEX IF NOT EXISTS idx_deaths_remort ON deaths(remort);
   ]]
   db:exec(sql)
   return not dbcheck(db:errcode(), db:errmsg(), "init_schema")
end

-- =============================================================================
-- Database open/close
-- =============================================================================
local function close_db()
   if db then
      db:close()
      db = nil
      db_path = nil
   end
end

local function open_db()
   if db then return true end

   local path = GetInfo(66) .. DB_FILENAME

   local handle, err_msg, err_code = sqlite3.open(path)
   if not handle then
      ColourNote("red", "", PREFIX .. "Failed to open database: " .. (err_msg or "unknown error"))
      return false
   end

   db = handle
   db_path = path

   if not init_schema() then
      close_db()
      return false
   end

   return true
end

-- =============================================================================
-- Combat state management
-- =============================================================================
local function start_fight(enemy_name)
   in_combat = true
   death_flag = false
   damage_total = 0
   round_count = 0
   last_enemypct = nil

   fight_start = {
      tnl = cached_tnl,
      gold = cached_gold,
      level = cached_level,
      zone = cached_zone or "Unknown",
      room_num = cached_room_num,
      room_name = cached_room_name,
      enemy = enemy_name,
   }
end

local function record_kill()
   if not fight_start then return end
   if not db then return end
   if not enabled then return end

   -- Calculate XP gained
   local xp_gained = 0
   if fight_start.tnl and cached_tnl and fight_start.level and cached_level then
      if cached_level > fight_start.level then
         -- Leveled up during combat
         xp_gained = fight_start.tnl + (cached_perlevel - cached_tnl)
      elseif cached_level == fight_start.level then
         -- Normal kill
         xp_gained = fight_start.tnl - cached_tnl
      end
      if xp_gained < 0 then xp_gained = 0 end
   end

   -- Calculate gold gained
   local gold_gained = 0
   if fight_start.gold and cached_gold then
      gold_gained = cached_gold - fight_start.gold
   end

   -- INSERT kill record
   local query = string.format(
      "INSERT INTO kills (timestamp, mob_name, zone, room_num, room_name, level, " ..
      "xp_gained, gold_gained, damage_total, rounds, tier, remort) " ..
      "VALUES (%d, %s, %s, %s, %s, %d, %d, %d, %d, %d, %s, %s)",
      os.time(),
      fixsql(fight_start.enemy),
      fixsql(fight_start.zone),
      fight_start.room_num and tostring(fight_start.room_num) or "NULL",
      fixsql(fight_start.room_name),
      fight_start.level or 0,
      xp_gained,
      gold_gained,
      damage_total,
      round_count,
      cached_tier and tostring(cached_tier) or "NULL",
      cached_remorts and tostring(cached_remorts) or "NULL"
   )

   db:exec(query)
   dbcheck(db:errcode(), db:errmsg(), query)
end

local function record_death()
   if not db then return end
   if not enabled then return end

   local enemy = (in_combat and fight_start) and fight_start.enemy or cached_enemy

   local query = string.format(
      "INSERT INTO deaths (timestamp, mob_name, zone, room_num, room_name, level, tier, remort) " ..
      "VALUES (%d, %s, %s, %s, %s, %d, %s, %s)",
      os.time(),
      fixsql(enemy),
      fixsql(cached_zone or "Unknown"),
      cached_room_num and tostring(cached_room_num) or "NULL",
      fixsql(cached_room_name),
      cached_level or 0,
      cached_tier and tostring(cached_tier) or "NULL",
      cached_remorts and tostring(cached_remorts) or "NULL"
   )

   db:exec(query)
   dbcheck(db:errcode(), db:errmsg(), query)
end

local function end_combat()
   in_combat = false
   fight_start = nil
   damage_total = 0
   round_count = 0
   last_enemypct = nil
end

-- =============================================================================
-- GMCP broadcast handler
-- =============================================================================
function OnPluginBroadcast(msg, id, name, text)
   if id ~= GMCP_HANDLER_ID then return end

   if text == "char.base" then
      local base = gmcp("char.base")
      if base then
         if base.perlevel then cached_perlevel = tonumber(base.perlevel) or 1000 end
         if base.tier then cached_tier = tonumber(base.tier) end
         if base.remorts then cached_remorts = tonumber(base.remorts) end
      end

   elseif text == "char.status" then
      local status = gmcp("char.status")
      if not status then return end

      -- Update cached values
      local new_level = tonumber(status.level)
      local new_tnl = tonumber(status.tnl)
      if new_level and new_level ~= -1 then cached_level = new_level end
      if new_tnl and new_tnl ~= -1 then cached_tnl = new_tnl end

      local new_enemy = status.enemy or ""

      -- State machine transitions
      if not enabled then
         cached_enemy = new_enemy
         return
      end

      if not in_combat then
         -- IDLE state
         if new_enemy ~= "" then
            -- Transition 1: IDLE --> COMBAT
            start_fight(new_enemy)
         end
      else
         -- COMBAT state
         if death_flag then
            if new_enemy == "" then
               end_combat()
            end
            cached_enemy = new_enemy
            return
         end

         if new_enemy == "" then
            -- Transition 3: COMBAT --> KILL_RECORDED --> IDLE
            record_kill()
            end_combat()

         elseif new_enemy ~= cached_enemy and cached_enemy ~= "" then
            -- Transition 4: COMBAT --> KILL_RECORDED --> COMBAT (enemy switch)
            record_kill()
            start_fight(new_enemy)

         else
            -- Transition 2: COMBAT --> COMBAT (same enemy, check round)
            local new_pct = tonumber(status.enemypct)
            if new_pct and new_pct ~= last_enemypct then
               round_count = round_count + 1
               last_enemypct = new_pct
            end
         end
      end

      cached_enemy = new_enemy

   elseif text == "char.worth" then
      local worth = gmcp("char.worth")
      if worth then
         local new_gold = tonumber(worth.gold)
         if new_gold then cached_gold = new_gold end
      end

   elseif text == "room.info" then
      local room = gmcp("room.info")
      if room then
         cached_zone = room.zone
         cached_room_num = tonumber(room.num)
         cached_room_name = room.name
      end
   end
end

-- =============================================================================
-- Text trigger handlers
-- =============================================================================
function ldb_on_damage_line(name, line, wildcards)
   if not in_combat then return end
   if not enabled then return end

   local dmg = tonumber(wildcards[1])
   if dmg then
      damage_total = damage_total + dmg
   end
end

function ldb_on_player_death(name, line, wildcards)
   if not enabled then return end

   death_flag = true
   record_death()
end

-- =============================================================================
-- Helper: format number with commas
-- =============================================================================
local function format_number(n)
   local formatted = tostring(n)
   while true do
      local k
      formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", "%1,%2")
      if k == 0 then break end
   end
   return formatted
end

-- =============================================================================
-- Helper: check DB is available for queries
-- =============================================================================
local function require_db()
   if not db then
      ColourNote("red", "", PREFIX .. "No database open. Try reloading the plugin.")
      return false
   end
   return true
end

-- =============================================================================
-- Command: ldb (status)
-- =============================================================================
function ldb_status(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Status")
   ColourNote("cyan", "", "  Enabled: " .. (enabled and "ON" or "OFF"))
   ColourNote("cyan", "", "  Database: " .. (db_path or "(none)"))

   if db then
      local kill_count = 0
      local death_count = 0
      for row in db:nrows("SELECT COUNT(*) as cnt FROM kills WHERE xp_gained > 0") do
         kill_count = row.cnt
      end
      for row in db:nrows("SELECT COUNT(*) as cnt FROM deaths") do
         death_count = row.cnt
      end
      ColourNote("cyan", "", "  Kills recorded: " .. format_number(kill_count))
      ColourNote("cyan", "", "  Deaths recorded: " .. format_number(death_count))
   end

   if cached_level then
      ColourNote("cyan", "", "  Current level: " .. cached_level)
   end
   if cached_zone then
      ColourNote("cyan", "", "  Current zone: " .. cached_zone)
   end
   if in_combat and fight_start then
      ColourNote("cyan", "", "  In combat: " .. fight_start.enemy ..
         " (round " .. round_count .. ", dmg " .. format_number(damage_total) .. ")")
   end
end

-- =============================================================================
-- Command: ldb help
-- =============================================================================
function ldb_help(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Commands:")
   ColourNote("cyan", "", "  ldb                     - Show status")
   ColourNote("cyan", "", "  ldb help                - Show this help")
   ColourNote("cyan", "", "  ldb on / off            - Enable/disable data collection")
   ColourNote("cyan", "", "  ldb level [N]           - Kill breakdown for level N (default: current)")
   ColourNote("cyan", "", "  ldb zone [name]         - Stats for a zone (default: current)")
   ColourNote("cyan", "", "  ldb mob <name>          - Stats for a mob (substring match)")
   ColourNote("cyan", "", "  ldb top mobs [N]        - Top N mobs by kill count (default 10)")
   ColourNote("cyan", "", "  ldb top zones [N]       - Top N zones by total XP (default 10)")
   ColourNote("cyan", "", "  ldb top xp [N]          - Top N mobs by avg XP per kill (default 10)")
   ColourNote("cyan", "", "  ldb deaths [N]          - Last N deaths (default 10)")
   ColourNote("cyan", "", "  ldb db                  - Database file info")
end

-- =============================================================================
-- Command: ldb on / ldb off
-- =============================================================================
function ldb_on(name, line, wildcards)
   enabled = true
   if not db then open_db() end
   ColourNote("cyan", "", PREFIX .. "Data collection enabled.")
end

function ldb_off(name, line, wildcards)
   enabled = false
   ColourNote("cyan", "", PREFIX .. "Data collection disabled.")
end

-- =============================================================================
-- Command: ldb level [N]
-- =============================================================================
function ldb_level(name, line, wildcards)
   if not require_db() then return end
   local level = tonumber(wildcards[1])
   if not level then
      level = cached_level
      if not level then
         ColourNote("red", "", PREFIX .. "Current level unknown. Try again after GMCP data arrives.")
         return
      end
   end
   show_level_stats(level)
end

function show_level_stats(level)
   ColourNote("cyan", "", PREFIX .. "Level " .. level .. " breakdown:")

   local total_kills = 0
   local total_xp = 0
   local total_gold = 0
   local total_damage = 0
   local total_rounds = 0
   local total_deaths = 0

   for row in db:nrows(string.format(
      "SELECT COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, COALESCE(SUM(gold_gained), 0) as gold, " ..
      "COALESCE(SUM(damage_total), 0) as dmg, COALESCE(SUM(rounds), 0) as rnd " ..
      "FROM kills WHERE level = %d AND xp_gained > 0", level)) do
      total_kills = row.cnt
      total_xp = row.xp
      total_gold = row.gold
      total_damage = row.dmg
      total_rounds = row.rnd
   end

   for row in db:nrows(string.format("SELECT COUNT(*) as cnt FROM deaths WHERE level = %d", level)) do
      total_deaths = row.cnt
   end

   if total_kills == 0 then
      ColourNote("yellow", "", "  No kills recorded at this level.")
      if total_deaths > 0 then
         ColourNote("red", "", "  Deaths: " .. total_deaths)
      end
      return
   end

   ColourNote("white", "", string.format("  Kills: %s | XP: %s | Gold: %s",
      format_number(total_kills), format_number(total_xp), format_number(total_gold)))
   ColourNote("white", "", string.format("  Damage: %s | Rounds: %s",
      format_number(total_damage), format_number(total_rounds)))

   local avg_xp = total_kills > 0 and math.floor(total_xp / total_kills) or 0
   ColourNote("white", "", string.format("  Avg XP/kill: %s", format_number(avg_xp)))

   if total_deaths > 0 then
      ColourNote("red", "", "  Deaths: " .. total_deaths)
   end

   -- Top mobs at this level
   ColourNote("cyan", "", "  Top mobs:")
   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE level = %d AND xp_gained > 0 " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT 5", level)) do
      count = count + 1
      ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
         count, row.mob_name, row.cnt, format_number(row.xp)))
   end

   -- Zones at this level
   ColourNote("cyan", "", "  Zones:")
   count = 0
   for row in db:nrows(string.format(
      "SELECT zone, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE level = %d AND xp_gained > 0 " ..
      "GROUP BY zone ORDER BY xp DESC LIMIT 5", level)) do
      count = count + 1
      ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
         count, row.zone, row.cnt, format_number(row.xp)))
   end
end

-- =============================================================================
-- Command: ldb zone [name]
-- =============================================================================
function ldb_zone(name, line, wildcards)
   if not require_db() then return end
   local zone_name = wildcards[1]
   if not zone_name or zone_name == "" then
      zone_name = cached_zone
      if not zone_name then
         ColourNote("red", "", PREFIX .. "Current zone unknown. Try again after GMCP data arrives.")
         return
      end
   end
   show_zone_stats(zone_name)
end

function show_zone_stats(zone_name)
   local like_pattern = "%" .. zone_name .. "%"

   local zones_found = {}
   for row in db:nrows(string.format(
      "SELECT DISTINCT zone FROM kills WHERE zone LIKE %s", fixsql(like_pattern))) do
      table.insert(zones_found, row.zone)
   end

   if #zones_found == 0 then
      ColourNote("yellow", "", PREFIX .. "No kills recorded in zones matching '" .. zone_name .. "'.")
      return
   end

   for _, zone in ipairs(zones_found) do
      ColourNote("cyan", "", PREFIX .. "Zone: " .. zone)

      for row in db:nrows(string.format(
         "SELECT COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, COALESCE(SUM(gold_gained), 0) as gold " ..
         "FROM kills WHERE zone = %s AND xp_gained > 0", fixsql(zone))) do

         if row.cnt > 0 then
            ColourNote("white", "", string.format("  Kills: %s | XP: %s | Gold: %s",
               format_number(row.cnt), format_number(row.xp), format_number(row.gold)))

            local avg_xp = math.floor(row.xp / row.cnt)
            ColourNote("white", "", string.format("  Avg XP/kill: %s", format_number(avg_xp)))
         end
      end

      -- Deaths in this zone
      for row in db:nrows(string.format(
         "SELECT COUNT(*) as cnt FROM deaths WHERE zone = %s", fixsql(zone))) do
         if row.cnt > 0 then
            ColourNote("red", "", "  Deaths: " .. row.cnt)
         end
      end

      -- Level range
      for row in db:nrows(string.format(
         "SELECT MIN(level) as min_lvl, MAX(level) as max_lvl " ..
         "FROM kills WHERE zone = %s AND xp_gained > 0", fixsql(zone))) do
         if row.min_lvl then
            ColourNote("white", "", string.format("  Level range: %d - %d", row.min_lvl, row.max_lvl))
         end
      end

      -- Top mobs
      ColourNote("cyan", "", "  Top mobs:")
      local count = 0
      for row in db:nrows(string.format(
         "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
         "FROM kills WHERE zone = %s AND xp_gained > 0 " ..
         "GROUP BY mob_name ORDER BY cnt DESC LIMIT 5", fixsql(zone))) do
         count = count + 1
         ColourNote("white", "", string.format("    %d. %s (%d kills, %s XP)",
            count, row.mob_name, row.cnt, format_number(row.xp)))
      end
   end
end

-- =============================================================================
-- Command: ldb mob <name>
-- =============================================================================
function ldb_mob(name, line, wildcards)
   if not require_db() then return end
   local mob_search = wildcards[1]
   local like_pattern = "%" .. mob_search .. "%"

   ColourNote("cyan", "", PREFIX .. "Mob search: " .. mob_search)

   local found = false
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, COALESCE(SUM(xp_gained), 0) as xp, " ..
      "COALESCE(SUM(gold_gained), 0) as gold, COALESCE(SUM(damage_total), 0) as dmg, " ..
      "COALESCE(SUM(rounds), 0) as rnd " ..
      "FROM kills WHERE mob_name LIKE %s AND xp_gained > 0 " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT 10", fixsql(like_pattern))) do

      found = true
      ColourNote("white", "", string.format("  %s: %d kills, %s XP, %s gold",
         row.mob_name, row.cnt, format_number(row.xp), format_number(row.gold)))

      local avg_xp = math.floor(row.xp / row.cnt)
      local avg_rnd = row.cnt > 0 and string.format("%.1f", row.rnd / row.cnt) or "0"
      ColourNote("white", "", string.format("    Avg XP: %s | Avg rounds: %s",
         format_number(avg_xp), avg_rnd))

      -- Zones where this mob was killed
      local zones = {}
      for zrow in db:nrows(string.format(
         "SELECT DISTINCT zone FROM kills WHERE mob_name = %s AND xp_gained > 0",
         fixsql(row.mob_name))) do
         table.insert(zones, zrow.zone)
      end
      if #zones > 0 then
         ColourNote("white", "", "    Zones: " .. table.concat(zones, ", "))
      end
   end

   if not found then
      ColourNote("yellow", "", "  No kills found matching '" .. mob_search .. "'.")
   end
end

-- =============================================================================
-- Command: ldb top mobs [N]
-- =============================================================================
function ldb_top_mobs(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " mobs by kill count:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE xp_gained > 0 " ..
      "GROUP BY mob_name ORDER BY cnt DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (%d kills, %s XP)",
         count, row.mob_name, row.cnt, format_number(row.xp)))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb top zones [N]
-- =============================================================================
function ldb_top_zones(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " zones by total XP:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT zone, COUNT(*) as cnt, SUM(xp_gained) as xp " ..
      "FROM kills WHERE xp_gained > 0 " ..
      "GROUP BY zone ORDER BY xp DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (%d kills, %s XP)",
         count, row.zone, row.cnt, format_number(row.xp)))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb top xp [N]
-- =============================================================================
function ldb_top_xp(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Top " .. limit .. " mobs by avg XP per kill:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT mob_name, COUNT(*) as cnt, SUM(xp_gained) as xp, " ..
      "CAST(SUM(xp_gained) AS REAL) / COUNT(*) as avg_xp " ..
      "FROM kills WHERE xp_gained > 0 " ..
      "GROUP BY mob_name HAVING cnt >= 3 " ..
      "ORDER BY avg_xp DESC LIMIT %d", limit)) do
      count = count + 1
      ColourNote("white", "", string.format("  %d. %s (avg %s XP, %d kills)",
         count, row.mob_name, format_number(math.floor(row.avg_xp)), row.cnt))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No mobs with 3+ kills recorded.")
   end
end

-- =============================================================================
-- Command: ldb deaths [N]
-- =============================================================================
function ldb_deaths(name, line, wildcards)
   if not require_db() then return end
   local limit = tonumber(wildcards[1]) or 10

   ColourNote("cyan", "", PREFIX .. "Last " .. limit .. " deaths:")

   local count = 0
   for row in db:nrows(string.format(
      "SELECT timestamp, mob_name, zone, level FROM deaths " ..
      "ORDER BY timestamp DESC LIMIT %d", limit)) do
      count = count + 1
      local time_str = os.date("%Y-%m-%d %H:%M", row.timestamp)
      local mob = row.mob_name or "unknown"
      ColourNote("white", "", string.format("  %s - Lvl %d - %s (%s)",
         time_str, row.level, mob, row.zone))
   end

   if count == 0 then
      ColourNote("yellow", "", "  No deaths recorded.")
   end
end

-- =============================================================================
-- Command: ldb db
-- =============================================================================
function ldb_db_info(name, line, wildcards)
   ColourNote("cyan", "", PREFIX .. "Database info:")
   ColourNote("white", "", "  Path: " .. (db_path or "(none)"))

   if not db then
      ColourNote("yellow", "", "  Database not open.")
      return
   end

   -- File size
   local f = io.open(db_path, "r")
   if f then
      local size = f:seek("end")
      f:close()
      if size < 1024 then
         ColourNote("white", "", "  Size: " .. size .. " bytes")
      elseif size < 1024 * 1024 then
         ColourNote("white", "", string.format("  Size: %.1f KB", size / 1024))
      else
         ColourNote("white", "", string.format("  Size: %.1f MB", size / (1024 * 1024)))
      end
   end

   -- Record counts
   for row in db:nrows("SELECT COUNT(*) as cnt FROM kills") do
      ColourNote("white", "", "  Total combat records: " .. format_number(row.cnt))
   end
   for row in db:nrows("SELECT COUNT(*) as cnt FROM kills WHERE xp_gained > 0") do
      ColourNote("white", "", "  Confirmed kills: " .. format_number(row.cnt))
   end
   for row in db:nrows("SELECT COUNT(*) as cnt FROM deaths") do
      ColourNote("white", "", "  Deaths: " .. format_number(row.cnt))
   end
end

-- =============================================================================
-- Plugin lifecycle
-- =============================================================================
function OnPluginInstall()
   enabled = (GetVariable("enabled") == "true")
   open_db()

   if enabled then
      ColourNote("cyan", "", PREFIX .. "Loaded (enabled).")
   else
      ColourNote("cyan", "", PREFIX .. "Loaded (disabled). Use 'ldb on' to start collecting data.")
   end
end

function OnPluginSaveState()
   SetVariable("enabled", tostring(enabled))
end

function OnPluginClose()
   close_db()
end

function OnPluginDisconnect()
   if in_combat then
      end_combat()
   end
end
]]>
</script>
</muclient>
